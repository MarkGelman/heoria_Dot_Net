 |. В какое-то время решили, что с потоками очень сложно работать из-за их очень ограниченого функционала.
	Тогда решили создать пространство имён TASK, которое даёт возможность легко работать с потоками.
	В их функционал входит:
		1. Возврат ответа из потока
		2. Прекратить работу одного потока и одновремено дать команду другому потоку начать работать
		3. Наследование потокоми от главного потока
		4. Дать возможность ждать потоку пока определёное к-во потоков(1,2,4,13....) из общего числа находящихся в работе не закончат
			работу.
		5. Использование ASYNC процесса
		6.	.........
		7. Task-и они всегда поумолчанию используются как background procecc (второстепеные) и поэтому всегда должны использоваться 
		   с командой типа wait.
		8. Task - берёт таски из ThreadPool.

 ||. Значение и синтаксис команд:

	 1. Task task1 = new Task(()=>{Thread.Sleep(5000);Console.WriteLine($"Hello from Task!");}); - создание новога таска с загрузкой внего задачи на выполнение
	    -- TaskCreationOption.LongRunning - пишется в конструкторе класса. Это команда даёт понять, что выполнение thread-а будет долгим, а
			значит этот thread взят не из ThreadPool
			Task t5 = Task.Run(()=> 
					{
						.
						.
						.

					},TaskCreationOption.LongRunning)
		-- Ниже приведена форма написания task-a который должен вернуть какое-либо значение:
		   Task <int> t5 = new Task<int>(()=> 
					{
						.
						.
						return 5

					},TaskCreationOption.LongRunning)

					t5.Start();
					int result = t5.Result;

		-- Task.WaitAll (t1,t2) -- ждёт пока task-и в скобках закончат свою работу;
		-- Task.WaitAny (t1,t2) -- ждёт пока какой-либо task в скобках закончит свою работу. После этого основной процесс завершит свою работу
									не ожидая остальных работающих task-ов

		-- Parallel -- это класс в функционале которого есть опция для цикла FOR
				Parallel.For(0,files.Lenght,index => {тело цикла})

	 2. task1.Run - запускает созданую выше задачу, но только для тасков, которые берутся из ThreadPool т.е конструктор таска не принимает параметров

	 3. Task t1 = Task.Run(()=>{...}) - создаёт (даёт имя) и сразу же запускает task  с вложением в нега задачи для выполнения;

	 4. Tри пути для WAIT:

	    1) t1.Wait => поскольку все task-и они запускаются как background, то это команда даёт команду главному процессу (такому как MAIN, к примеру)
		   не заканчиваться пока t1 не закончит свою работу ;
		2) IsCompleted - возвращает значение типа bool,которое определяет продолжает task свою работу или нет;
				while (!t2.IsCompleted)
				{
					Thread.Sleep(10) - !!!																										!!!
											всегда надо писать эту строку, т.к. без неё при использовании данной команды происходит перегрузка
											процессора
									   !!!																										!!!
				}
		3) t2.Result - возвращает результат thread-a и не даёт завершится основному процессу пока не будет получен результат ;

	 5. Task t2 = Task.Factory.StartNew(()=>{...}), any parameter) - тоже самое что и RUN,но здесь после запятой можно добавлять ещё параметры
		для оброботки,хранящейся в t2, задаче.

	 6. t2.Status - показывает в какой стадии выполнения находится данный task (run,cancel,faulted ....).Возвращает string.

	 7. t2.Faulted - показывает что task не закончил свою работу по причине какого-то фатального фактора (ошибка, к примеру).Возвращает boolean;

	 8. EXECPTION - в task-ах мы не увидим прекращения программы при возникновении какой-либо ошибки, т.к. все task-и они background thread.
		Есть несколько путей увидеть,что произошла ошибка:
		1) Использовать t2.Status - при ошибке получим => faulted;
		2) t2.Result - как результат получим вид произошедшей ошибки;
		3) t2.Wait - показывает ошибку так как мы ждём окончания thread-а;
		4) t2.RunSynchonously - команда переводит данный процесс из статуса async в sync,т.е. ждёт пока t2 завершит свою работу;
		5) try-catch block - но при использовании этого блока мы не всегда сможем узнать точную ошибку. В определёных случаях он будет выдавать
			название, которое носит основной EXECEPTION внутри которого находится та действительная ошибка, которая случилась в данный момент
		6) !!!									!!!
					САМЫЙ ПРИЕМЛЕМЫЙ СПОСОБ
		   !!!									!!!
		   if (t2.Faulted)
		   {
				t2.Exception.Handle(e =>
				{
					Console.WriteLine(e);
					return true;
				})
				
		   } - только в такой форме мы получим ту ошибку, которая действительно произошла;

    9. Сanceletion Token -- это способ остановить task во время, что он RUN. Пункты работы:
	   1) CancellationTokenSource -- класс который содержит функционал для решения данной задачи;
	   2) В области для создания переменной класса создаём CancellationTokenSource tokenSource -- создаём объект данного класса;
	   3) tokenSource.Cancel -- команда закрывает работу task-a. Она всегда находится после закрытия тела task-а (за ним); 
	   4) Если несколько способов "сказать" task-у закрыться.Нужоно написать в точке предпологаемого принудительного закрытия внутри тела task-а в любой из булеаных ф-ций (IF,WHILE ....)
		  одну из следующих опций:
			а. 
				 If (tokenSource.IsCancellationRequested) -- попросил ли кто-то закрыть данный task. По умолчанию false 
				 {
					throw new OperationCanceledException -- эту строчку добавляют из-за того, чтобы быть уверен, что причиной прерывания 
														    работы task-а была команда tokenSource.Cancel, а не какая нибуд фатальная ошибка
															программы!!!!!!
				 }

			б. Второй способ - это просто написать выше приведённые 3 строчки одной строкой:
				tokenSource.Token.ThrowIfCancellationRequested();

			в. Третий способ он лучше всего, когда принудительное прерывание программы записывает в конструкторе task-а:
				Task t5 = Task.Run(()=> 
				{
					.
					.
					.

				},tokenSource.Token)

				Этот способ позволяет получить информацию в каком статусе находится данный task. В случае закрытия task-a 
				через tokenSource значения будут следующими:

					t5.Status => Canceled
					t5.IsCanceled => true
					t5.IsFaulted => false



	10. ContinueWith позволяет в одном RUN запустить последовательно несколько task-ов:
		Task res = Task.Run<int>(()=> 
				{
					.
					.
					.

				}).ContinueWith((Task<int> antecendent) => 
				{
					.
					.
					.

				}).ContinueWith((Task<int> antecendent) => 
				{
					.
					.
					.

				})

		Все эти таски связаны механизмом, который называется Depended Exejection - Каждый последующий task может получить результат предыдущего
		Этот результат записывается и передаётся следующему task-у через => Task<int> antecendent 

	11.  Класс TaskContinuationOptions - содержит функционал для управления task-ом. Несколько опций этого класса:
			Task t5 = Task.Run(()=> 
				{
					.
					.
					.

				},.ContinueWith(antecendent =>{...},TaskContinuationOptions.NotOnFaulted - продолжай, если не было фатальной ошибки в наследуемом Task-е или
				  TaskContinuationOptions.OnlyOnFaulted - продолжай, только в том случае,если фатальной ошибки не было)
				   

III. Async away pattern:
	1. 
 