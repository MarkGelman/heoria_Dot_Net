
------------------------------------------------------------ PROGRAM.CS ------------------------------------------------------------

Вся программа состоит из потоков (тредов) (VS,Word,Any Desk...) кот состоят из threads.Процесс заканчивается только когда заканчиваются
все его потоки.
Foreground - важный тред
Daemon - второстепеный тред.Процессор может задействовать только один трэйд одновременно.
Библиотека TPN разбивает большой трэйд на несколько трейдов более маленьких. К примеру, Main - это трэйд, кот в свою очередь можно
разбить на несколько небольших трэйдов.

Если в режиме Debug навести курсор на ct то в intellicenc получим следующую инфу:
     IsAlive (true/false) => продолжает работать или закончился;
     IsBackground (true/false) => трэйд главный или второстепеный;
     IsThreadPoolThread (true/false) => это патерн в проге кот позволяет концентрировать много трэйдов в одном месте,
        чтобы их можно было быстро задействовать;
     ManagedThreadId => это трэйд кот привязан к CLR. На курсе мы будем работать толька с такими трэйдами;
     Name => имя не всегда вводят -- эта вещь не обязательна;
     Priority => Степень значимости данного трэйда (HiPriority,Normal,LowPriority). Уже не используют т.к было много проблем
     ThreadState => на каком этапе находится данный трэйд (Running, Start ...)

 int result = Convert.ToInt32(Console.ReadLine()) --> Этот процесс называется "BLOCKING". В это время комп висит и ждёт пока
     пользователь  введёт требуюмую инфу. Чтобы избежать такую потерю времени были придуманы трэйды ("THREAD")
 Трэйды предназначены, для того чтобы в это время комп что-то делал, а не ждал пока дейтсвующий процесс закончится.
Thread t1_ = new Thread(() => { }) --> так создают Thread по имени "t1" с "lambda expression" --> это безымяная фукция где "() =>
     означает что это функция у которой есть тело. Тело функции пишут в "{}"
                
Thread t1 = new Thread(foo) -- создаёт Thread по имени t1 ,кот обращается к функции кот не является безымяной.
     (в даном примере обращении идёт к ф-ции по имени "foo"):

Thread.Sleep(1000) --> он прекращает работу Thread на то к-во времени кот указано в скобках. Выполнил итерацию 
      и "заснул" --> указаное время прошло --> "проснулся" и выполнил следующую итерацию цикла в Main.

После выполнения приведённого ниже -- t1.Start() -- трэд по имени t1 начнёт выполняться. А трэд Main "заснёт". 

Трэд t1 выполнит свои десять итераций в ф-ции "foo" раньше, чем трэд Main проснётся т.к каждая итерация его цикла "засыпает"
на 80 милисекунд, то есть весь цикл выполнится за 80*10=800 милисекунд а "сон" Main длится 1000 милисекунд(Sleep(1000))
800<1000 --> поэтому цикл ф-ции foo выполнится быстрее чем "проснётся" трэд в MAIN.
В том случае, когда трэйд  t1 не успервает полностью выполнить весь цикл до того когда трэд MAIN проснётся (t1.Sleep(200) -->
200*10 = 2000 --> 2000 > 1000), то эти два трэда начинают работать одновремено 

t1.IsBackground = true --> это распоряжение превращает трэд t1 во второстепеный трэд. Все второстепеные трэды заканчиваются вместе с
    основным трэдом (в нашем случае основной трэд это MAIN) и не важно успели они закончится или нет. По умолчанию все трэды являются
    основными ("foreground"), т.е "IsBackground = false". Чтобы "превратить" их во второстепеные используется команда "IsBackground
    = true"

Если нужно сохранить все трэды как основные, но при этом они все должны закончится с завершением работы MAIN, то для этого нужно
использовать команду ABORT. Для этого нужно поместить все трэды кроме MAIN в отдельный LIST:
    
 
Thread.CurrentThread.ManagedThreadId} --> эта команда возвращает порядковый номер трэда (его уникальное имя или номер), кот
    автоматически присваивает ему комп.
    static void Main(string[] args)
    { 
            List<Thread> threads = new List<Thread>();
            for (int i = 3; i >= 0; i--)
            {
                ...............
                ...............
                ...............
                Thread t1 = new Thread(foo);
                threads.Add(t1);
                ..............
                .............
            }
            ......................
            ........................
            threads.ForEach(_ => _.Abort());
     }
     Команда  ----------- threads.ForEach(_ => _.Abort());-------------- ставится перед закрытием блока MAIN  

Чтобы проверить сколько времени берёт выполнение той или иной команды (в нашем случае трэд) можно использовать пространство имён 
    "STOPWATCH":
        Stopwatch sw = new Stopwatch();
        sw.Start();
        Thread t1 = new Thread(foo);
        t1.IsBackground = true;
        t1.Start();
        sw.Stop();
        long ticks = sw.ElapsedMilliseconds;

**************************************************************************************************************************************
*                                            СИСТЕМА РАБОТЫ THREAD-а     31-01-21                                                    *        *
**************************************************************************************************************************************

1. UNSTARTED - тред не подключён к работе
2. Started - находится на старте ожидая выстрела стартового пистолета. Ещё не включён в работу.
3. RUNING - тред начинает выполнять функцию которя в нём хранится. Когда же время отведёное ему процессором заканчивается, но ф-ция в
            треде ещё не закончила работу(процессор переодически прерывает работу треда, чтобы запустить в работу другой тред) --> трэд
            снова возвращается в положение STARTED (положение 2) cнова ожидая выстрела стартового пистолета и так пока функция в треде
            не закончит свою работу!!!        
4.SLEEP(time) - выполняя данный оператор,тред впадает в спячку на время указаное в скобках возвращаясь в положение (2).
5.WAIT() - возвращает тред в положение (2), но в отличие от (4) тред может снова не вернуться в работу до конца выполнения программы.
            если указать в скобках время, то тред подождёт до конца отведённого ему времени и если ни кто его не вызвал, то только 
            тогда возвращается в положение (2).
6.JOIN - тред прекращает свою работу пока другой указаный тред не закончит свою.Используется когда трабуется взаимосвязаная работа
         ф-ций находящихся в разных тредах.
7.Yield - возвращает тред на позицию (2), но на очень короткое время. Используется в основном для задержки выполнения треда
7.SUSPEND - останавливает тред и только после RESUME тред возвращается в положение (2).
8.ABORT - тред прекращает свою работу безотносительно того закончила его ф-ция работу или нет.
9.BLOCK - связан с процессами которые находятся вне системы .NET.

10.ThreadPool - это внутрений класс .NET являющийся "кладовой" для тредов. Он позволяет получить новый тред без получение объекта класса TREAD.
             Тоесь не нужно получать объект класса через new Tread(),что очень сокращает время работы программы . Это экономит очень много времени когда требуется исполнить большое к-ва тредов.
             когда требуется исполнить большое к-ва тредов.
             * TreadPool - это background потоки (второстепеные)
             * TreadPool - использовать когда работа потока требует мало времени.
             * TreadPool - эффективен и рекомендован к применению только когда нужно выполнить большой объём работы для которого требуется большое к-во потоков.
             * Чтобы "вытянуть" новый тред из этого класса, нужно вызвать его ф-цию:

                    TreadPool.QueueUserWorkItem(имя ф-ции требуемой для загрузки в данный поток. Эта ф-ция обязана принимать опционый параметр типа object
                    (не обязательный к передаче в эту ф-цию, но обязательный к написанию в объявлении данной ф-ции));
                    

11. Thread safe - коллекция или список, или словарь называются thread safe, если для работы с ними можно использовать несколько потоков одновременно
        * Библиотека System.Collection.Concurrent - позволяет делать из коллекций или словарей (!!!не из листов!!!) thread safe посредством встреных 
          в эту библиотеку листов коллекций и словарей.
          К примеру:
             System.Collection.Concurrent.ConcurrentDictionary<int,int> dict = new  System.Collection.Concurrent.ConcurrentDictionary<int,int>();
           используя этот встроеный словарь нет нужды использовать блок LOCK при одновременой работе нескольких потоков с данным словарём. 
           Данный инструмент создаёт свои блоки "за кулисами".
        * Для LIST-ов есть своя библиотека, и она:
            List list = ArrayList.Sinchronized(new List<int>());
----------------------------------------------------------- join_treads.cs -----------------------------------------------------------
1. Если после 
                    Thread counterThread = new Thread(() =>
            {
                for (int i = 1; i <= 5; i++)
                {
                    Console.WriteLine(i);
                    Thread.Sleep(1 * 1000);
                }
            });

   1) если после выше приведёный строк написать сразу же оператор counterThread.Start() - то функция не закончится пока тред не перестанет
        работать так как данный тред является важным.
   2) если после закрытия лямбда-выражения написать :

                                            counterThread.IsBackground = true;
                                            counterThread.Start();

      то тогда ф-ция прекратит свою работу да окончания работы counterThread, так как указали что этот тред не является важным.
   3) если после закрытия лямбда-выражения написать :

                                           
                                            counterThread.Join();
                                            
      то тогда ф-ция будет ждать окончания треда, так как указан оператор counterThread.Join() и тогда не важно является лиcounterThread
      главным или второстепеным потоком.
      
--------------------------------------- !!!PATTERN_QUEUE!!! -----------------------------------------------------------

Паттерн "Очередь" используется когда есть очень много работы, а ресурсов для неё мало. К примеру, требуется обработать 10000 делегатов,
а потоков для этого имеется только 1000. Поэтому ставят действия в LIST и заряжают их поочерёдно в процесс при наличии свободного потока.
Но при этом возникает масса проблем.Чтобы понять что делает паттерн "QUEUE" и зачем он нужен, сначала нужно понять откуда возникают
проблемы при обработке большого к-ва делегатов малым к-вом потоков. 
    1.Синтаксис программы:
        1) Поля:
            А. List<Action> m_queue = new List<Action>() -- "очередь" (лист) из делегатов хранящих в себе какие либо ф-ции на выполнение;
            Б. List<Thread> m_workers -- лист потоков для распаковки делегатов и выполнения находящихся в них ф-ций;
        2) Свойства:
            А. public int Count -- возвращает к-во членов (делегатов хранящих в себе какие либо ф-ции на выполнение)
                                   списка "List<Action> m_queue":
                                                                     return m_queue.Count;
        3) Функции класса:
            А. public void Produce(Action work):
               А) получает делегат с вложеной в него какой-то ф-цией на выполнение
               Б) ставит полученый делегат в "очередь" (записывает его в List<Action> m_queue )
            Б.  public void Consume()
                А) создаёт пустой делегат Action work_func = null;
                Б) создаёт ему условия  без ошибок принять  делегат из List<Action> m_queue :
                                                                                    work_func = m_queue[m_queue.Count - 1]
                В) запускает данный поток в работу;
                Д) удаляет принятый в работу делегат из очереди (из List<Action> m_queue);

        3) Конструкторы 
            А. По умолчанию: 
               А) образует пустой объект класса, который позволяет пользователю заполнить List<Action> m_queue делегатами на выполнение.
                  посредством ф-ции public void Produce(Action work);
            Б. С аргументами:
                А) принимает ввиде параметра к-во свободных потоков public public Pattern_Queue(int num_workers)
                Б) инициализирует  m_workers = new List<Thread>();
                В) инициализирует свободный поток в цикле. Итерации цикла равны к-ву свободных потоков.
                Г) вкладывает в каждый новый поток ф-цию Consume 
                                                                Thread one_thread = new Thread(Consume);
                Д) добавляет каждый такой поток в  List<Thread> m_workers;
                Е) вызывает ф-цию Consume при помощи запуска каждого новообразованого потока;

    2. При реализации данного синтаксиса возникает масса проблем и все они находятся в ф-ции CONSUME(другое название "CRITICAL AREA"):
        1) при следующем виде ф-ции ()
                                                public void Consume()
                                                        {
                                                            Action work_func = null;
                                                            work_func = [m_queue.Count - 1]; // 1
                                                            m_queue.RemoveAt(m_queue.Count - 1); // 1
                                                            work_func.Invoke();
                                                        }
           могут возникнуть сразу две проблемы:
            А. поскольку процессы происходят очень быстро, то ф_ция Produce может  не успеть заполнить "очередь" ("List<Action> m_queue")
                и тогда делегат work_func будет пуст и просто "умрёт" ничего при этом не сделав. 
                Решение в том чтобы  перед присвоением делегату work_func значения, проверить List<Action> m_queue на null.И тут ещё
                одна проблема. Если это сделать через IF, то проверка будет одноразовая. Т.е. если действительно равен null, то ф-ция
                Consume продолжиться выполнятьс и work_func опять "умрёт" пустым так ничего и не сделав. Поэтому решение оно может быть
                только одним -- использовать цикл WHILE c вложеной в него минимальнейшей задержкой.
                В таком случае ф-ция будет выглядеть так:
                                                            public void Consume()
                                                            {
                                                                Action work_func = null;
                                                                While (m_queue.Count == 0)
                                                                {
                                                                        thread.Yield();
                                                                }
                                                                work_func = [m_queue.Count - 1]; // 1
                                                                m_queue.RemoveAt(m_queue.Count - 1); // 1
                                                                work_func.Invoke();
                                                            }
               
            Б.  Две проблемы решены циклом While. Но возникает ещё одна. Процессы, как уже было сказано, происходят очень
              быстро. Поэтому возможено, что сразу несколько потоков зайдут в ф-цию Consume и все они одновременно начнут
              удалять один и тот же делегат из списка m_queue --> ОШИБКА!!! Сбой программы. 
              Чтобы решить данную проблему был создан блок LOCK.
                Lock (key) - это блок в котором помещенно д-вие, которое не могут делать два треда одновременно,
              где key - это пустой объект(или "ключ", подпись которого находиться вместе с подписью других полей 
              программы,который используется как булеаная переменная, которая закрывает дверь,когда поток находится
              внутри блока LOCK,чтобы не находилось внутри блока больше одного потока!!! Следует помнить, что
              использование одного и тогоже имени ключа в разных блоках LOCK,делает для этих блоков общую дверь --> 
              когда закрыт один блок то и второй закрыт. Поэтому для разных блоков LOCK требуются разные имена
              ключей (разные объекты)!!!!
              Когда в блок заходит один тред, то блок автоматически закрывается. В такой блок не может зайти одновременно
              больше чем один тред. Когда тред внутри блока закончит свою работу --> ключ от блока(key) передаётся
              следующемутреду, который "ждёт" на входе в блок.
                Применив данный блок,наша ф-ция будет выглядеть так:
                                                          public void Consume()
                                                            {
                                                                // critical section
                                                                // lock -- Monitor.Enter
                                                                Action work_func = null;
                                                                lock (key)
                                                                {
                                                                    while (m_queue.Count == 0)
                                                                    {
                                                                        Thread.Yield();
                    
                                                                    }
                                                                    work_func = m_queue[m_queue.Count - 1]; // 1
                                                                    m_queue.RemoveAt(m_queue.Count - 1); // 1
                                                                    work_func.Invoke();
                                                                }
                                                            } 
           В.  Возникает ещё одна последняя проблема. При запуске work_func внутри LOCK (work_func.Invoke();)
              work_func не сможет передать ключ следующему потоку пока не завершит свою работу --> 
              не нужная потеря времени. Поэтому запуск work_func должен осуществляться не внутри, а снаружи
              блока LOCK.

              !!!  ВСЁ ВЫШЕ СКАЗАНОЕ И ОБЪЯСНЁННОЕ И ЯВЛЯЕТСЯ ПАТТЕРНОМ "QUEUE"  !!!
  

  !!!                                                                                                                !!!
        Важно, что запуск треда (в нашем случае work_func.invoke()) должен быть сделан не в LOCK-блоке,а после него.
        Так как в ином случае тред не выйдет из блока пока не закончит свою работу --> другой тред не сможет зайти
        --> не нужная потеря времени!
  !!!                                                                                                                !!!

  **************************************************************** 07-02-21 ***************************************************************************
  
  ----------------------------------------------------------- !!! SINGLTON_PATTERN !!! 07-02-21 -----------------------------------------------------------
|.Идея этого паттерна в том, чтобы всё что бы если есть класс который отвечает

||.Требования к паттерну:
    1.Должен быть только один постоянный объект у класса (как статик)
    2.Должна быть только одна статистическая ф-ция создающая этот объект
    3.Только через один постоянный объект можно будет получить доступ к функционалу класса
    4.Невозможно будет создать больше одного объекта класса(Reference всегда тодлжен указывать на одну и туже область на "КУЧЕ")
    5.Код должен быть Thread-safe
    6.Нельзя обнулить SINGELTON
|||.
    Пишем код класса SINGLETON исходя из его требования
      1)Чтобы невозможно было созадать болеше одного объекта класса -- конструктор класса должен быть PRIVATE

            private ClockSingleton()
            {

            }
         но тогда неводможно будет создать вообще объект?!Поэтому:
      2)Создадим публичную переменую класса для постоянного хранения объекта:
          public ClockSingleton Instance;
          
          private ClockSingleton()
            {

            }
        но чтобы использовать её из другого класса нужно создать в этом классе  объект класса в которой находится эта переменная, а это снова 
        невозможно сделать так как конструктор класса он PRIVATE?! Как же можно добиться от программы сделать требуемый объект этого класса?!
      3) Решение заключается в том, что в данных условиях объкт класса может создать только сам класс. И сделать он может это через свою ф-цию,
        которая и будет создавать данный объект. Но опять же эта ф-ция должна быть PRIVATE, чтобы невозможно было создать объект из других классов:
         public ClockSingleton Instance;
         private ClockSingleton GetInstance()
            {
               Instance = new ClockSingleton;
               return Instance;
            }
          private ClockSingleton()
            {

            }
        Всё хорошо, да снова не очень. Мы снова не можем создать объект класса поскольку уровень её доступа он PRIVATE?!
        В каком же случае можно да сделать возможным использование ф-ции PRIVATE без создания объекта класса

      4) Выход он только один -- сделать эту ф-цию статистической:

         public ClockSingleton Instance;
         private static ClockSingleton GetInstance()
            {
               Instance = new ClockSingleton;
               return Instance;
            }
          private ClockSingleton()
            {

            }
        Кажется проблема решена, но мы не можем обратиться к не статистическому полю Instance из ф-ции которая статистическая?!
        Ответ напрашивается сам собой...
      5) Сделаем не статистическое поле Instance статистическим:
             public static ClockSingleton Instance;
             private static ClockSingleton GetInstance()
                {
                   Instance = new ClockSingleton;
                   return Instance;
                }
              private ClockSingleton()
                {

                }
         И опять всё хорошо да не очень. У нас 6-ым пунктом в требованиях для SINGELTON-а занчиться невозможность его изменения, но сейчас когда 
         публичное поле  стало статистическим, то ничего не мешает обратиться и изменить  его обратившись к нему просто через имя класса?!
         Что же делать?! 
         Нет ничего проще да и нет другого выхода!!!

      6) Нужно изменить уровень доступа к этому полю на PRIVATE:
                 private static ClockSingleton Instance;
                 private static ClockSingleton GetInstance()
                    {
                       Instance = new ClockSingleton;
                       return Instance;
                    }
                  private ClockSingleton()
                    {

                    }
         Но тогда мы снов не можем получить объект класса поскольку все доступные для этого средства имеют уровень доступа private?!
         Решение оно в том...
      7) Нет другого выхода как снова сделать ф-ию GetInstance public:
                 private static ClockSingleton Instance;
                 public static ClockSingleton GetInstance()
                    {
                       Instance = new ClockSingleton();
                       return Instance;
                    }
                  private ClockSingleton()
                    {

                    }
    8) Пока ещё не понятно зачем нам вообще нужно поле Instance (зачем нужно сохранять созданный объект). Это требуется для того чтобы выполнилось
       4 требование к классу типа SINGLETON -- объект такого класса должен быть всегда один. Используя выше приведёный код можно к примеру в
       классе PROGRAMM сравнить два объекта класса SINGLETON:
          ClockSingleton.GetInstance() == ClockSingleton.GetInstance()
      согласитесь, что если оставить код таким как мы его написали, то мы получим два разных объекта, которые по хеш коду не будут равны, а согласно
      трабованию к классу они должны быть равны. Решение в проверке поля INSTANCE на NULL:

            private static ClockSingleton Instance;
            public static ClockSingleton GetInstance()
            {
                if (Instance == null)
                {
                        Instance = new ClockSingleton();
                }
                return Instance;
            }

    9) Чтобы сделать испоьзование ф-ции GetInstance() потоками в форме Treade-safe. Нужно использовать блок LOCK.
        Для этого нужно создать объект ключа (key) который должен быть статистического типа, так как блок находится внутри статистической ф-ции:

            private static ClockSingleton Instance;
            private static object key = new object();
            public static ClockSingleton GetInstance()
            {
                    lock (key)
                    {
                        if (Instance == null)
                        {
                            Instance = new ClockSingleton();
                        }
                    }
                return Instance;
            }  

    10) Данный код соответствует всем трабованиям, но всё ещё не идеален.
        Если представить себе ситуацию, что созданых потоков огромное к-во и все хотят одновремено получить объект нашего класса, то тогда выстроиться
        огромная очередь из потоков, перед блоком LOCK, которые будут ждать только одного -- проверку или объект уже существует. Огромная, не нужная
        потеря времени работы программы!!!!! Решение оно очень простое ....
        Нужно осуществить проверку "создан ли уже объект" перед блоком LOCK !!!!! Если создан, то нет проблемы, чтобы несколько потоков одновременно
        получили один и тот же объек, поскольку этот объект уже создан и нет возможности создать ещё один такой же. Другими словами в этом случае нет
        проблемы Multitrade ==> такая операция называется "Отомик оперешин".

            private static ClockSingleton Instance;
            private static object key = new object();
            public static ClockSingleton GetInstance()
            {
                if (Instance == null)
                {
                    lock (key)
                    {
                        if (Instance == null)
                        {
                            Instance = new ClockSingleton();
                        }
                    }
                }
                return Instance;
            }

        Возникает впечатление, что IF внутри блока LOCK он лишний. Но это обманчиво, так как создание области Treade-safe оно было не для того чтобы
        проверить создан ли уже объект, а для того чтобы этот объект не был создан одновременно несколькими потоками(требование номер 4).Возможна
        ситуация при которой несколько потоков зайдут одновременно в ф-цию GetInstance ==> одновремено проверят Instance на Null и также одновременно
        зайдут в "критическую область" . Блок Lock впустит один поток,чтобы создать Instance.После этого зайдёт второй поток и снова создаст Instance
        в том случае,если снова не проверить Instance на Null, что бы избежать этого проверка на Null.Поэтому, чтобы были достикнуты все цели, проверка
        на Null должна быть как снаружи блока Lock так и внутри него.
        
        
   --------------------------------------------------------------- MONITOR_LOCK -----------------------------------------------------------------
            
       {Monitor.Enter......... Monitor.Exsit} - делает туже ф-ция что и  LOCK, но если пользоваться только Monitor, то при возникновении ошибки 
       в процессе выполнения программы поток умрёт не передав ключ следующему потоку, что приведёт к фатальному сбою в работе программы. Поэтому,
       чтобы этого избежать кроме команды Monitor и при её использовании надо обернуть код в блок try-catch-finally при чём Monitor.Exsit следует
       поставить в блок finally, для того чтобы влюбом случае ключ был передан по очереди.LOCK включает в себя и команду Monitor и по умолчанию
       оборачивает код в его блоке в блок try-catch-finally. LOCK похож по своей работе на работу команды Using().
        Есди посмотреть в ILDASM, то мы не увидим так команды лок, а увидим команды Monitor обёрнутые в блок try-catch-finally  .



 **************************************************************** 10-02-21 *************************************************************************** 
 
   -------------------------------------------------------- !!! PATTERN FACED !!! -----------------------------------------------------------------

       Нет ничего сложного в этом патерне. Просто нужно создать класс который бедет вызывать различные ф-ции из различных классов.
       Подобно пункту управления.

***************************************** Blog "WaitHandle (ManualResetEvent,AutoResetEvent)" ****************************************************

Способы для синхронизации работы Thread-ов которые не требуют использования LOCK or WAITE:

I. static ManualResetEvent mre = new ManualResetEvent (false) - изначально всегда false всегда изначально закрыт;
    1. ManualResetEvent mre => это "ворота"
    2. mre.WaitOne() -- подожди перед воротами пока откроются. Эта команда пишется внутри функции,которая внутри thread;
    3. mre.Set() -- открывает "ворота". Это команда пишется в точке программы, где нужно открыть ворота перед выше упомянутым thread;
    4. mre.WaitOne(100) -- Thread ждёт не больше 100 миллисекунд и продолжает свою работу не взависимости от того открыты ворота или нет;
    5. mre.Reset() - закрывает ворота;
II. static AutoResetEvent mre = new AutoResetEvent (false) - изначально всегда false всегда изначально закрыт:
    1. AutoResetEvent mre -- это "ворота";
    2. mre.WaitOne() -- подожди перед воротами пока откроются. Эта команда пишется внутри функции,которая внутри thread;
    3. mre.Set() -- открывает "ворота". Это команда пишется в точке программы, где нужно открыть ворота перед выше упомянутым thread;
    4. Эти ворота запускают только один thread и сразу закрываются автоматически без всякой команды. Открываются они только после того как
       thread внутри закончит свою работу.