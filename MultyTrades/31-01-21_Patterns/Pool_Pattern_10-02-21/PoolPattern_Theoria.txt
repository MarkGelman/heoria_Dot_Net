  |.Pool - место где содержиться много Items
    Хорошо использовать для POOL-а класс QUEUE => первый кто зашёл он же первый который выходит. А так же удобные расширение для извлечения
    ITEM-а (Dequeue()) , а так же для ввода (Enqueue())
 ||.Синтаксис паттерна:
	1.У нас есть две функции GetConnection и RestoreConnection
		 public MyDbConnection GetConnection()      И        public MyDbConnection RestorConnection()           
    2. В функции  GetConnection() поток получает connection , а в ф-ции  RestorConnection() возвращает  
    3. В этих двух ф-циях есть критическая область:
        1) в первой,чтобы два треда не получили одну и туже connection
        2) во второй, чтобы не произошёл случай, когда ондновремено в первой функции один поток получает connection,а во второй другой поток возвра-
            щает другую connection (это как растягивать что-то в две разные стороны. Это что-то в конечном итоге может порваться) при чём чтобы этого
            абсолютно избежать мало использовать блок LOCK нужно ещё, чтобы у этих двух блоков, находящихся в разных ф-циях, был один и тот же ключ
            (key)
        
        !!!                                                                                                                                         !!!

             Есть в .Net namespace CONCERRENTQUEUE - это сбор коллекций, которые позволяют делать разные д-вия одновременно без ущерба для 
             выполнения программы. В этом случае нет нужды ставить LOCK в ф-ции RestoreConnection(). Но тут есть недостаток. Такие коллекции сами
             ставят (автоматом) блок на всё (где надо и где не надо) => что забирает много драгоценного времени работы программы. Поэтому надо 
             хорошо подумать воспользоваться этими внутреними коллекциями .Net или нет.

        !!!                                                                                                                                         !!!

     3. Проблема такой конструкции в том, что если не будет дать connection потоку в первой ф-ции, то тред пойдёт спать вместе с ключом
        ==> и тогда поток который захочет вернуть connection не сможет этого сделать ==> потеря драгоценного времени и не только!!!!
        Возможна более ужасная ситуация при которой поток ожидающий connection не сможет её получить, поскольку она находится в потоке,
        который должен эту самую connection вернуть. А он не сможет этого сделать от слова вообще, поскольку ключ от входа в ф-цию,
        возвращающей эту connection в POOL находится у потока, который ожидает её, а ключ вернуть не может (ключ то один и тот же для
        двух разных LOCK-ов). Такая ситуация называетс "ДЭД ЛОК" Что же делать???!!!

     4. WAIT(key):
        Нужно сделат так,чтобы при ситуации когда в пуле нет connections, поток не шёл "спать" вместе с ключом, а возвращал его следу-
        ющему в очереди, и только после этого шёл "спать".
            Чтобы это осуществить создана команда WAIT.Она как бы заводит поток в комнату для ожиданий.
            Но возникает вопрос, а как поток узнает, что есть connection ???!!!

    5. PULSE or PULSEALL -- возвращет потоки из комнаты ожиданий один или несколько соответственно!!!
       Эти команды добавляются в код в ф-цию RestoreConnection после команды которая возвращает connection в pool.

    6. Race Condition -- в процессе возврата из комнаты ожидания ключ может попасть не тому потоку, кот вышел из комнаты, а новому
       потоку который зашёл в ф-цию GetConnection(), а может и да попадёт. Кто из этих потоков в действительность получит "ключ" 
       мы знать не можем. 
       Такая ситуация называется -- "Race Condition""
    7. Блок IF!!!
        Если в блоке LOCK наличие connection провереятся через команду IF, то по возвращении потока из комнаты ожидания может 
        возникнуть проблема следующего толка. 
        Дело всё в том, что поток возвращается на команду WAIT => это значит, что он уже не проверяет pool на то есть ли в нём
        connection или нет!!! => может возникнуть ситуация,что пока этот поток возвращался из комнаты ожидания, в ф-цию GetConnection
        зашёл другой поток и забрал существующую connection => возвращающийся поток возвращается внутрь блока IF => не проверяет pool 
        на наличие connection => программа получает фатальную ошибку. Что же делать???!!!
    8. Если вместо блока IF использовать цикл WHILE, то проблема будет решена так как возвращающийся поток вернётся внутрь цикла и не
        выйдет из него пока снова не проверит POOL на NULL => проблема решена!!!!!!

       
        
           
|||.
|\/.
 \/.
\/|.